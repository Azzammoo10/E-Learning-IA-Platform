{
    "cours": {
        "titre": "Intelligence Artificielle",
        "institution": "Université Mohammed V - EST Salé",
        "filiere": "MI-GEII 2ème année",
        "professeur": "Halima HOUSNY",
        "parties": [
            {
                "id": 1,
                "titre": "Introduction au Machine Learning",
                "contenu": {
                    "definition": "L'apprentissage automatique (Machine Learning) vise à donner aux machines la capacité d'apprendre à partir de données, en s'appuyant sur des algorithmes.",
                    "types_de_donnees": [
                        "mots",
                        "chiffres",
                        "statistiques",
                        "images"
                    ],
                    "lien_avec_IA": "C'est un champ d'études de l'Intelligence Artificielle qui simule l'apprentissage, une forme d'intelligence humaine.",
                    "etapes_developpement": [
                        {
                            "etape": 1,
                            "nom": "Sélection des données d'entraînement",
                            "description": "Préparer un ensemble de données étiquetées (résultat prédéfini) ou non étiquetées (le modèle extrait les caractéristiques lui-même)."
                        },
                        {
                            "etape": 2,
                            "nom": "Sélection de l'algorithme",
                            "description": "Le choix dépend du type et volume de données et de la nature du problème."
                        },
                        {
                            "etape": 3,
                            "nom": "Entraînement de l'algorithme",
                            "description": "Exécuter l'algorithme, comparer les résultats et ajuster jusqu'à obtenir le bon résultat."
                        },
                        {
                            "etape": 4,
                            "nom": "Utilisation et amélioration du modèle",
                            "description": "Déployer le modèle sur un nouveau jeu de données lié au problème à résoudre."
                        }
                    ],
                    "types_apprentissage": [
                        {
                            "type": "Apprentissage supervisé",
                            "description": "Les algorithmes apprennent grâce à un jeu de données étiquetées avec un résultat prédéfini."
                        },
                        {
                            "type": "Apprentissage non supervisé",
                            "description": "Formation de base avec des données non étiquetées et sans résultat associé."
                        },
                        {
                            "type": "Apprentissage par renforcement",
                            "description": "Les algorithmes apprennent par essais, erreurs et récompenses (Trial and error)."
                        }
                    ]
                }
            },
            {
                "id": 2,
                "titre": "Algorithmes de l'Apprentissage Supervisé",
                "sous_parties": [
                    {
                        "titre": "Introduction",
                        "contenu": {
                            "principe": "Apprend la relation entre les caractéristiques et la cible à partir de l'ensemble de données.",
                            "types": [
                                "Classification",
                                "Régression"
                            ],
                            "distinction": {
                                "regression": "Prédit une valeur continue (quantité).",
                                "classification": "Prédit une classe ou catégorie."
                            }
                        }
                    },
                    {
                        "titre": "La Classification",
                        "contenu": {
                            "definition": "Type d'apprentissage supervisé qui prédit un résultat discret (Vrai/Faux, Oui/Non, 0/1).",
                            "exemple": {
                                "contexte": "Prédire si un client bancaire sera en défaut de paiement.",
                                "caracteristiques": "historique de crédit, prêts, investissements",
                                "cible": "0 ou 1 (défaut ou non)"
                            },
                            "algorithmes": [
                                "Régression logistique",
                                "Arbre de décision",
                                "K plus proches voisins (KNN)",
                                "Forêt aléatoire",
                                "Réseaux neuronaux"
                            ],
                            "applications": [
                                {
                                    "application": "Classification des e-mails de spam",
                                    "type": "Classification"
                                },
                                {
                                    "application": "Détection de fraudes",
                                    "type": "Classification"
                                },
                                {
                                    "application": "Reconnaissance et classification d'images",
                                    "type": "Classification"
                                },
                                {
                                    "application": "Analyse de sentiments",
                                    "type": "Classification"
                                },
                                {
                                    "application": "Conversion de la langue parlée en texte",
                                    "type": "Classification"
                                },
                                {
                                    "application": "Diagnostic médical",
                                    "type": "Classification"
                                },
                                {
                                    "application": "Prévision des ventes",
                                    "type": "Régression"
                                }
                            ]
                        }
                    },
                    {
                        "titre": "La Régression",
                        "contenu": {
                            "definition": "Prédit des valeurs continues telles que ventes, salaire, poids ou température.",
                            "exemples_application": [
                                "Identifier les facteurs influençant la rentabilité d'un investissement",
                                "Prévoir les ventes futures en analysant les ventes passées",
                                "Anticiper le comportement des consommateurs",
                                "Prédire le prix d'une maison en fonction de ses caractéristiques"
                            ]
                        }
                    },
                    {
                        "titre": "Régression Linéaire",
                        "contenu": {
                            "objectif": "Créer un modèle décrivant la relation entre une variable dépendante et une ou plusieurs variables indépendantes.",
                            "explication_simple": "La régression linéaire trace la meilleure ligne droite à travers vos données. Imaginez des points sur un graphique : cette droite passe le plus près possible de tous les points pour prédire de nouvelles valeurs. Si X augmente, Y augmente (ou diminue) de manière proportionnelle.",
                            "methodes_python": [
                                {
                                    "nom": "Méthode 1 : Calcul manuel avec NumPy",
                                    "description": "On calcule la pente (m) et l'ordonnée (c) à la main avec les formules mathématiques.",
                                    "code": "import numpy as np\n\n# Données\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([3, 4, 2, 4, 5])\n\n# Calcul de la pente m et ordonnée c\nx_mean = x.mean()\ny_mean = y.mean()\nm = np.sum((x - x_mean) * (y - y_mean)) / np.sum((x - x_mean)**2)\nc = y_mean - m * x_mean\n\nprint(f'Équation: y = {c:.1f} + {m:.1f}x')\nprint(f'Prédiction pour x=6 : {c + m*6:.1f}')",
                                    "resultat": "Équation: y = 2.4 + 0.4x\nPrédiction pour x=6 : 4.8"
                                },
                                {
                                    "nom": "Méthode 2 : Avec scikit-learn",
                                    "description": "On utilise la bibliothèque sklearn qui fait tout le calcul automatiquement.",
                                    "code": "from sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Données (X doit être 2D pour sklearn)\nX = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)\ny = np.array([3, 4, 2, 4, 5])\n\n# Créer et entraîner le modèle\nmodel = LinearRegression()\nmodel.fit(X, y)\n\nprint(f'Pente (m): {model.coef_[0]:.1f}')\nprint(f'Ordonnée (c): {model.intercept_:.1f}')\nprint(f'Prédiction pour x=6 : {model.predict([[6]])[0]:.1f}')",
                                    "resultat": "Pente (m): 0.4\nOrdonnée (c): 2.4\nPrédiction pour x=6 : 4.8"
                                }
                            ],
                            "types": {
                                "simple": "Une seule variable indépendante → une variable dépendante.",
                                "multiple": "Plusieurs variables indépendantes → une variable dépendante."
                            },
                            "equation": "y = c + mx",
                            "parametres": {
                                "c": "Point d'intersection avec l'axe des ordonnées (y)",
                                "m": "Pente de la droite"
                            },
                            "methode": "Méthode des moindres carrés",
                            "formule_pente": "m = Σ(x - x̄)(y - ȳ) / Σ(x - x̄)²",
                            "fonctions_evaluation": [
                                {
                                    "nom": "MSE (Mean Squared Error)",
                                    "formule": "MSE = (1/N) * Σ(yᵢ - ŷ)²",
                                    "interpretation": "Une valeur plus faible indique une meilleure performance prédictive."
                                },
                                {
                                    "nom": "R² (Coefficient de détermination)",
                                    "formule": "R² = Σ(y_pred - ȳ)² / Σ(y - ȳ)²",
                                    "interpretation": "Plus R² est élevé, plus la distance entre les points réels et la droite diminue, meilleure est la performance."
                                }
                            ],
                            "exemples": [
                                {
                                    "nom": "Exemple 1",
                                    "donnees": [
                                        {
                                            "x": 1,
                                            "y": 3
                                        },
                                        {
                                            "x": 2,
                                            "y": 4
                                        },
                                        {
                                            "x": 3,
                                            "y": 2
                                        },
                                        {
                                            "x": 4,
                                            "y": 4
                                        },
                                        {
                                            "x": 5,
                                            "y": 5
                                        }
                                    ],
                                    "resultats": {
                                        "moyenne_x": 3,
                                        "moyenne_y": 3.6,
                                        "m": 0.4,
                                        "c": 2.4,
                                        "equation": "y = 2.4 + 0.4x",
                                        "MSE": 0.72,
                                        "R2": 0.3
                                    }
                                },
                                {
                                    "nom": "Exemple 2 - Prédiction prix maison",
                                    "donnees": [
                                        {
                                            "surface_m2": 80,
                                            "prix_vente_eur": 350000
                                        },
                                        {
                                            "surface_m2": 100,
                                            "prix_vente_eur": 450000
                                        },
                                        {
                                            "surface_m2": 60,
                                            "prix_vente_eur": 200000
                                        },
                                        {
                                            "surface_m2": 120,
                                            "prix_vente_eur": 550000
                                        },
                                        {
                                            "surface_m2": 75,
                                            "prix_vente_eur": 250000
                                        }
                                    ],
                                    "resultats": {
                                        "moyenne_x": 87,
                                        "moyenne_y": 360000,
                                        "m": 6032.11,
                                        "c": -164793.58,
                                        "equation": "y = -164793.58 + 6032.11x",
                                        "MSE": 535550458.72,
                                        "R2": 0.97
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "titre": "K Plus Proches Voisins (KNN)",
                        "contenu": {
                            "definition": "Algorithme de ML supervisé simple, non paramétrique, qui mémorise les observations pour classifier les données de test.",
                            "principe": "Trouver les k échantillons les plus proches du point de test et prédire sa classe selon la majorité.",
                            "explication_simple": "KNN fonctionne comme dans la vraie vie : pour deviner ce qu'est un objet inconnu, on regarde les K objets les plus proches de lui. Si 3 voisins sur 5 sont des chats → c'est probablement un chat ! On mesure la distance (comme avec une règle) et on vote à la majorité.",
                            "methodes_python": [
                                {
                                    "nom": "Méthode 1 : Calcul manuel avec NumPy",
                                    "description": "On calcule les distances nous-mêmes et on vote à la majorité.",
                                    "code": "import numpy as np\n\n# Données d'entraînement\nX_train = np.array([[2,4],[4,2],[4,4],[4,6],[6,4]])\ny_train = np.array(['A','A','B','B','B'])\n\n# Point à classifier\npoint = np.array([5, 5])\nk = 3\n\n# Calculer les distances\ndistances = np.sqrt(np.sum((X_train - point)**2, axis=1))\n\n# Trouver les K plus proches\nidx = np.argsort(distances)[:k]\nvoisins = y_train[idx]\n\n# Voter à la majorité\nfrom collections import Counter\nresultat = Counter(voisins).most_common(1)[0][0]\nprint(f'Les {k} voisins: {voisins}')\nprint(f'Prédiction: classe {resultat}')",
                                    "resultat": "Les 3 voisins: ['B' 'B' 'B']\nPrédiction: classe B"
                                },
                                {
                                    "nom": "Méthode 2 : Avec scikit-learn",
                                    "description": "On utilise KNeighborsClassifier de sklearn pour faire tout automatiquement.",
                                    "code": "from sklearn.neighbors import KNeighborsClassifier\nimport numpy as np\n\n# Données d'entraînement\nX_train = np.array([[2,4],[4,2],[4,4],[4,6],[6,4]])\ny_train = np.array(['A','A','B','B','B'])\n\n# Créer et entraîner le modèle avec K=3\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(X_train, y_train)\n\n# Prédire le point (5,5)\nprediction = knn.predict([[5, 5]])\nprint(f'Prédiction: classe {prediction[0]}')",
                                    "resultat": "Prédiction: classe B"
                                }
                            ],
                            "etapes": [
                                "Sélectionner le nombre K de voisins",
                                "Calculer la distance du point non classifié aux autres points",
                                "Prendre les K voisins les plus proches",
                                "Compter le nombre de points par catégorie parmi ces K voisins",
                                "Attribuer la catégorie la plus présente"
                            ],
                            "formules_distance": {
                                "euclidienne": "d = √(Σ(xᵢ - yᵢ)²)",
                                "manhattan": "d = Σ|xᵢ - yᵢ|"
                            },
                            "choix_k": "Un k trop petit → surapprentissage. Un k trop grand → sous-apprentissage.",
                            "exemples": [
                                {
                                    "nom": "Exemple 1 - Classification de points",
                                    "donnees_apprentissage": [
                                        {
                                            "x": 2,
                                            "y": 4,
                                            "classe": "A"
                                        },
                                        {
                                            "x": 4,
                                            "y": 2,
                                            "classe": "A"
                                        },
                                        {
                                            "x": 4,
                                            "y": 4,
                                            "classe": "B"
                                        },
                                        {
                                            "x": 4,
                                            "y": 6,
                                            "classe": "B"
                                        },
                                        {
                                            "x": 6,
                                            "y": 4,
                                            "classe": "B"
                                        }
                                    ],
                                    "echantillon_test": {
                                        "x": 5,
                                        "y": 5
                                    },
                                    "k": 3,
                                    "distances": [
                                        {
                                            "point": [
                                                2,
                                                4
                                            ],
                                            "classe": "A",
                                            "distance": 3.1622
                                        },
                                        {
                                            "point": [
                                                4,
                                                2
                                            ],
                                            "classe": "A",
                                            "distance": 3.1622
                                        },
                                        {
                                            "point": [
                                                4,
                                                4
                                            ],
                                            "classe": "B",
                                            "distance": 1.4142
                                        },
                                        {
                                            "point": [
                                                4,
                                                6
                                            ],
                                            "classe": "B",
                                            "distance": 1.4142
                                        },
                                        {
                                            "point": [
                                                6,
                                                4
                                            ],
                                            "classe": "B",
                                            "distance": 1.4142
                                        }
                                    ],
                                    "prediction": "B"
                                },
                                {
                                    "nom": "Exemple 2 - Détection Spam",
                                    "donnees_apprentissage": [
                                        {
                                            "mots_suspects": 1,
                                            "longueur": 120,
                                            "spam": 0
                                        },
                                        {
                                            "mots_suspects": 2,
                                            "longueur": 150,
                                            "spam": 0
                                        },
                                        {
                                            "mots_suspects": 8,
                                            "longueur": 90,
                                            "spam": 1
                                        },
                                        {
                                            "mots_suspects": 6,
                                            "longueur": 100,
                                            "spam": 1
                                        },
                                        {
                                            "mots_suspects": 1,
                                            "longueur": 200,
                                            "spam": 0
                                        },
                                        {
                                            "mots_suspects": 9,
                                            "longueur": 80,
                                            "spam": 1
                                        },
                                        {
                                            "mots_suspects": 2,
                                            "longueur": 180,
                                            "spam": 0
                                        },
                                        {
                                            "mots_suspects": 7,
                                            "longueur": 95,
                                            "spam": 1
                                        }
                                    ],
                                    "echantillon_test": {
                                        "mots_suspects": 4,
                                        "longueur": 110
                                    },
                                    "k": 5,
                                    "prediction": 1,
                                    "interpretation": "SPAM"
                                }
                            ]
                        }
                    }
                ]
            },
            {
                "id": 3,
                "titre": "Algorithmes de l'Apprentissage Non Supervisé",
                "sous_parties": [
                    {
                        "titre": "Introduction",
                        "contenu": {
                            "definition": "Identifie des clusters ou groupes en fonction de données non étiquetées, avec très peu d'intervention humaine.",
                            "categorie_principale": "Clustering"
                        }
                    },
                    {
                        "titre": "Clustering",
                        "contenu": {
                            "principe": "Regrouper les données en clusters homogènes ayant des caractéristiques communes.",
                            "definition_formelle": "Organiser des objets de sorte que ceux d'un même groupe soient plus semblables entre eux qu'avec ceux des autres groupes.",
                            "applications": [
                                "Reconnaissance des formes",
                                "Analyse d'images",
                                "Analyse de la clientèle",
                                "Analyse des réseaux sociaux"
                            ],
                            "algorithme_principal": "K-moyennes (K-means)"
                        }
                    },
                    {
                        "titre": "K-Means",
                        "contenu": {
                            "definition": "Divise des points en k groupes (clusters) homogènes et compacts.",
                            "explication_simple": "K-Means, c'est comme organiser des billes par couleur sans connaître les couleurs à l'avance. On place K drapeaux au hasard, chaque bille rejoint le drapeau le plus proche, puis on déplace chaque drapeau au centre de son groupe. On répète jusqu'à ce que les groupes ne changent plus !",
                            "methodes_python": [
                                {
                                    "nom": "Méthode 1 : Calcul manuel avec NumPy",
                                    "description": "On code les étapes de K-Means nous-mêmes étape par étape.",
                                    "code": "import numpy as np\n\n# Données\ndata = np.array([[25,65],[30,70],[22,55],[35,80],[28,60],[40,85]])\nk = 2\n\n# Initialiser les centroïdes (prendre les 2 premiers points)\ncentroids = data[:k].copy()\n\nfor _ in range(10):  # 10 itérations\n    # Calculer la distance de chaque point aux centroïdes\n    distances = np.array([np.sqrt(np.sum((data - c)**2, axis=1)) for c in centroids])\n    # Assigner chaque point au centroïde le plus proche\n    labels = np.argmin(distances, axis=0)\n    # Recalculer les centroïdes\n    for i in range(k):\n        centroids[i] = data[labels == i].mean(axis=0)\n\nprint(f'Centroïdes finaux: {centroids}')\nprint(f'Groupes: {labels}')",
                                    "resultat": "Centroïdes finaux: [[25. 60.] [35. 78.33]]\nGroupes: [0 0 0 1 0 1]"
                                },
                                {
                                    "nom": "Méthode 2 : Avec scikit-learn",
                                    "description": "On utilise KMeans de sklearn pour tout faire en 3 lignes.",
                                    "code": "from sklearn.cluster import KMeans\nimport numpy as np\n\n# Données\ndata = np.array([[25,65],[30,70],[22,55],[35,80],[28,60],[40,85]])\n\n# Créer et entraîner le modèle avec K=2\nkmeans = KMeans(n_clusters=2, n_init=10, random_state=42)\nkmeans.fit(data)\n\nprint(f'Centroïdes: {kmeans.cluster_centers_}')\nprint(f'Groupes: {kmeans.labels_}')\nprint(f'Prédire un nouveau point: {kmeans.predict([[32, 72]])}')",
                                    "resultat": "Centroïdes: [[25. 60.] [35. 78.33]]\nGroupes: [0 0 0 1 0 1]\nPrédire un nouveau point: [1]"
                                }
                            ],
                            "formule_distance": "d(p,q) = √(Σ(pᵢ - qᵢ)²)",
                            "etapes": [
                                "Choisir le nombre de clusters K",
                                "Initialiser K centroïdes aléatoirement",
                                "Calculer la distance euclidienne de chaque point vers chaque centroïde",
                                "Affecter chaque point au centroïde le plus proche",
                                "Recalculer les centroïdes comme la moyenne des points du cluster",
                                "Répéter jusqu'à convergence (centroïdes stables) ou nombre max d'itérations atteint"
                            ],
                            "critere_arret": "Les centroïdes ne changent plus (convergence) ou le nombre maximal d'itérations est atteint.",
                            "exemple": {
                                "description": "Clustering d'étudiants par âge et poids",
                                "k": 3,
                                "implementation_sklearn": "kmeans = KMeans(n_clusters=3, n_init=10); kmeans.fit(data)"
                            }
                        }
                    }
                ]
            },
            {
                "id": 4,
                "titre": "Algorithmes de l'Apprentissage par Renforcement",
                "sous_parties": [
                    {
                        "titre": "Introduction",
                        "contenu": {
                            "definition": "Méthode d'apprentissage pour la prise de décision. L'agent optimise sa politique d'action π grâce à des récompenses positives et négatives.",
                            "principe": {
                                "environnement_etat": "L'environnement est dans un état st.",
                                "action": "L'agent effectue une action at.",
                                "transition": "L'état devient st+1 et une récompense rt est reçue.",
                                "fonction_transition": "Établit le passage de st à st+1 sous l'effet de at."
                            },
                            "elements_fondamentaux": {
                                "agent": "Entité qui apprend et prend des décisions.",
                                "environnement": "Monde dans lequel l'agent évolue.",
                                "etat_s": "Situation actuelle de l'agent.",
                                "action_a": "Choix possible dans un état donné.",
                                "recompense_r": "Retour immédiat reçu après une action."
                            }
                        }
                    },
                    {
                        "titre": "Q-Learning",
                        "contenu": {
                            "definition": "Permet à un agent d'apprendre la meilleure action dans chaque état, sans connaître le modèle de l'environnement.",
                            "explication_simple": "Q-Learning, c'est comme apprendre le meilleur chemin dans un labyrinthe. L'agent essaie différentes directions, note les bons chemins (récompenses +) et les mauvais (récompenses -) dans un tableau (Q-Table). Petit à petit, il mémorise quelle action faire dans chaque situation pour gagner le maximum !",
                            "methodes_python": [
                                {
                                    "nom": "Méthode 1 : Q-Table manuelle avec NumPy",
                                    "description": "On crée la Q-Table et on met à jour les valeurs nous-mêmes.",
                                    "code": "import numpy as np\n\n# Environnement simple : 4 états, 2 actions\nn_states = 4\nn_actions = 2\nQ = np.zeros((n_states, n_actions))  # Q-Table initialisée à 0\n\nalpha = 0.1   # vitesse d'apprentissage\ngamma = 0.9   # facteur d'actualisation\n\n# Simuler un épisode\nstate = 0\naction = 1        # choisir action 1\nreward = 5        # récompense reçue\nnext_state = 2    # nouvel état\n\n# Mise à jour Q-Table\nQ[state, action] = Q[state, action] + alpha * (\n    reward + gamma * np.max(Q[next_state]) - Q[state, action]\n)\n\nprint('Q-Table après mise à jour:')\nprint(Q)",
                                    "resultat": "Q-Table après mise à jour:\n[[0.  0.5]\n [0.  0. ]\n [0.  0. ]\n [0.  0. ]]"
                                },
                                {
                                    "nom": "Méthode 2 : Avec Gymnasium (OpenAI Gym)",
                                    "description": "On utilise la bibliothèque gymnasium pour un environnement prêt à l'emploi.",
                                    "code": "import gymnasium as gym\nimport numpy as np\n\n# Créer l'environnement FrozenLake\nenv = gym.make('FrozenLake-v1', is_slippery=False)\n\n# Initialiser la Q-Table\nQ = np.zeros((env.observation_space.n, env.action_space.n))\nalpha, gamma, epsilon = 0.8, 0.95, 0.1\n\n# Entraîner pendant 1000 épisodes\nfor episode in range(1000):\n    state, _ = env.reset()\n    done = False\n    while not done:\n        # Choisir action (exploration vs exploitation)\n        if np.random.random() < epsilon:\n            action = env.action_space.sample()  # explorer\n        else:\n            action = np.argmax(Q[state])  # exploiter\n        \n        next_state, reward, done, _, _ = env.step(action)\n        Q[state, action] += alpha * (reward + gamma * np.max(Q[next_state]) - Q[state, action])\n        state = next_state\n\nprint('Q-Table entraînée (extrait):')\nprint(Q[:4].round(2))",
                                    "resultat": "Q-Table entraînée (extrait):\n[[0.   0.77 0.73 0.  ]\n [0.   0.   0.81 0.  ]\n [0.   0.86 0.   0.  ]\n [0.   0.   0.   0.  ]]"
                                }
                            ],
                            "contrainte": "S'applique uniquement si le nombre d'états n et d'actions m sont finis et de taille raisonnable.",
                            "q_table": {
                                "description": "Tableau de valeurs. Lignes = états s, Colonnes = actions a. Q(s,a) = récompense totale (gain) espérée.",
                                "politique": "a = π(s) = argmax Q[s,:] — l'agent choisit l'action avec la meilleure valeur Q."
                            },
                            "formule_mise_a_jour": "Q[s,a] = Q[s,a] + α * [r + γ * max_a' Q(s',a') - Q[s,a]]",
                            "parametres": {
                                "alpha": "Vitesse d'apprentissage (0 à 1).",
                                "gamma": "Facteur d'actualisation (0 à 1).",
                                "epsilon": "Paramètre équilibre exploration/exploitation."
                            },
                            "exploration_vs_exploitation": {
                                "exploitation": "Utiliser la Q-table pour choisir l'action maximale.",
                                "exploration": "Agir de façon aléatoire.",
                                "epsilon_valeurs": {
                                    "0.2": "20% du temps l'agent explore",
                                    "0.0": "exploitation pure",
                                    "1.0": "exploration pure"
                                }
                            },
                            "algorithme_pseudocode": [
                                "Initialiser Q[s,a]",
                                "Répéter N épisodes:",
                                "  Initialiser l'état s",
                                "  Répéter:",
                                "    Choisir action a depuis s (Q + aléatoire)",
                                "    Observer récompense r et état s'",
                                "    Mettre à jour Q[s,a] = Q[s,a] + α[r + γ*max_a'Q(s',a') - Q(s,a)]",
                                "    s := s'",
                                "  Jusqu'à nombre max de boucles"
                            ],
                            "exemple": {
                                "grille": "4×4",
                                "depart": [
                                    0,
                                    0
                                ],
                                "objectif": [
                                    3,
                                    3
                                ],
                                "case_interdite": [
                                    1,
                                    1
                                ],
                                "actions": {
                                    "0": "haut",
                                    "1": "bas",
                                    "2": "gauche",
                                    "3": "droite"
                                },
                                "recompenses": {
                                    "objectif": 10,
                                    "deplacement": -1,
                                    "case_interdite": -10
                                },
                                "chemin_optimal": [
                                    [
                                        0,
                                        0
                                    ],
                                    [
                                        0,
                                        1
                                    ],
                                    [
                                        0,
                                        2
                                    ],
                                    [
                                        1,
                                        2
                                    ],
                                    [
                                        1,
                                        3
                                    ],
                                    [
                                        2,
                                        3
                                    ],
                                    [
                                        3,
                                        3
                                    ]
                                ]
                            }
                        }
                    }
                ]
            }
        ]
    }
}